import 'dart:async';
import 'dart:io';

import 'package:change_case/change_case.dart';
import 'package:path/path.dart' as p;
import 'package:watcher/watcher.dart';
import 'package:yaml/yaml.dart';

import '../models/flutter_app.dart';
import '../version.g.dart';

/// Handle flutter assets related operations.
class FlutterAssetsService {
  /// Create a new [FlutterAssetsService].
  const FlutterAssetsService(this.app);

  /// The Flutter app.
  final FlutterApp app;

  /// Get list of assets path defined in `pubspec.yaml`.
  Future<List<String>> getAssetsPathFromPubspec() async {
    final readAsString = await app.pubspecFile.readAsString();
    final pubspec = loadYaml(readAsString) as YamlMap;
    if (pubspec case {'flutter': {'assets': [...final assets]}}) {
      final paths = <String>[];
      for (final asset in assets) {
        switch (asset) {
          case String():
            paths.add(asset);
          case YamlMap():
            paths.add(asset['path'] as String);
        }
      }
      return paths;
    }
    return []; // no assets defined in pubspec
  }

  /// Get list of all assets [File]s defined in `pubspec.yaml`.
  Future<List<File>> getAssetFiles({required List<String> paths}) async {
    final filePaths = <String>[];
    for (final path in paths) {
      final absolutePath = p.join(app.rootDirectory.path, path);
      if (absolutePath.endsWith('/')) {
        // get all files in the directory
        final directory = Directory(absolutePath);
        if (!directory.existsSync()) continue;
        final files = directory.listSync().whereType<File>();
        filePaths.addAll(files.map((e) => e.path));
      } else {
        final file = File(absolutePath);
        if (!file.existsSync()) continue;
        filePaths.add(file.path);
      }
    }
    return filePaths.toSet().map(File.new).toList();
  }

  /// Generate the `assets.dart` file containing the assets paths.
  Future<void> generateAssetClass({
    required List<File> files,
    required String className,
  }) async {
    final assetContent = StringBuffer(_generatedFileComment)
      ..writeln('abstract class $className {');

    for (final e in files) {
      final path = e.path.split('${app.rootDirectory.path}/').last;
      assetContent.writeln(
        "  static const String ${path.toCamelCase()} = '$path';",
      );
    }
    assetContent.writeln('}');

    final assetFile = File(
      p.join(app.rootDirectory.path, 'lib', 'generated', 'assets.dart'),
    );
    if (!assetFile.existsSync()) await assetFile.create(recursive: true);
    await assetFile.writeAsString(assetContent.toString());
  }

  /// Listen pubspec.yaml and asset file changes.
  /// Invokes [listener] upon change detection.
  Future<void> listenForChanges(void Function() listener) {
    // TODO(albin): add throttling
    final subscriptions = <StreamSubscription<WatchEvent>>[];
    // need to cancel this?
    Watcher(app.pubspecFile.path).events.listen((_) async {
      await Future.wait(subscriptions.map((e) => e.cancel()));
      subscriptions.clear();
      final files = await getAssetFiles(
        paths: await getAssetsPathFromPubspec(),
      );
      final directories = files.map((e) => e.parent.path).toSet();
      for (final directory in directories) {
        final sub = Watcher(directory).events.listen((_) => listener());
        subscriptions.add(sub);
      }
      listener(); // initial trigger
    });
    listener(); // initial trigger
    return Completer<void>().future; // never completes
  }

  static const _generatedFileComment =
      '''
// dart format off

/// This file is **auto-generated** by the `flu asset` command.
///
/// **DO NOT edit this file manually.**
///
/// Generated using the `flu` CLI (v$fluVersion):
/// https://pub.dev/packages/flu
''';
}
